#!/usr/bin/env python3
"""
Create Memory Dump with Malware Artifacts
Author: Manoj Santhoju
Institution: National College of Ireland

This script creates a memory dump sample that includes malware simulation artifacts
for testing the forensics framework.
"""

import os
import struct
import random
import sys
from datetime import datetime
from pathlib import Path

def create_malware_memory_dump(filename="memory_dump_with_malware.raw", size_mb=50, os_type="windows"):
    """Create a memory dump that includes malware simulation artifacts"""
    print(f"Creating {os_type} memory dump with malware artifacts: {filename} ({size_mb}MB)")
    
    test_data = bytearray()
    
    # Add OS signature
    if os_type.lower() == "windows":
        test_data.extend(b'Windows NTOSKRNL Microsoft Corporation')
        test_data.extend(b'\x00' * 100)
        
        # Add malware simulation artifacts
        malware_artifacts = [
            b'suspicious_encrypted.dat',
            b'temp_credentials.txt',
            b'stolen_data.bin',
            b'keylogger_output.log',
            b'backdoor_config.cfg',
            b'suspicious_process.py',
            b'malware_test_environment',
            b'copy_suspicious_encrypted.dat',
            b'hidden_file.dat'
        ]
        
        # Add processes with malware indicators
        process_count = random.randint(40, 100)
        malware_processes = [
            ('suspicious_process.py', 10636),
            ('python.exe', 10636),
            ('cmd.exe', random.randint(1000, 9999)),
            ('powershell.exe', random.randint(1000, 9999))
        ]
        
        for i in range(process_count):
            if i < len(malware_processes):
                pid, name = malware_processes[i][1], malware_processes[i][0]
            else:
                pid = random.randint(1000, 9999)
                process_names = ['explorer.exe', 'chrome.exe', 'notepad.exe', 'svchost.exe']
                name = random.choice(process_names)
            
            test_data.extend(struct.pack('<I', pid))
            name_bytes = name.encode('utf-8')
            test_data.extend(name_bytes)
            test_data.extend(b'\x00' * (32 - len(name_bytes)))
            
            # Add command line with malware indicators
            if 'suspicious' in name.lower() or 'python' in name.lower():
                cmd_line = f"{name} --network --file-access".encode('utf-8')
                test_data.extend(cmd_line)
                test_data.extend(b'\x00' * (64 - len(cmd_line)))
        
        # Add network connections (suspicious ports from simulation)
        suspicious_ports = [8080, 4444, 5555, 6666]
        for port in suspicious_ports:
            local_ip = f"127.0.0.1"
            remote_ip = f"{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}"
            network_str = f"{local_ip}:{port}->{remote_ip}:{random.randint(1, 65535)}".encode('utf-8')
            test_data.extend(network_str)
            test_data.extend(b'\x00' * (64 - len(network_str)))
        
        # Add malware artifacts as file references
        for artifact in malware_artifacts:
            test_data.extend(b'FILE_REF:')
            test_data.extend(artifact)
            test_data.extend(b'\x00' * (64 - len(artifact)))
        
        # Add registry-like modifications
        test_data.extend(b'REGISTRY_MOD:')
        test_data.extend(b'HKEY_CURRENT_USER\\Software\\TestKey')
        test_data.extend(b'\x00' * 50)
        
    elif os_type.lower() == "linux":
        test_data.extend(b'Linux kernel vmlinux')
        test_data.extend(b'\x00' * 100)
        
        # Add malware artifacts
        malware_artifacts = [
            b'suspicious_encrypted.dat',
            b'temp_credentials.txt',
            b'stolen_data.bin',
            b'keylogger_output.log',
            b'backdoor_config.cfg'
        ]
        
        # Add processes
        process_count = random.randint(40, 100)
        for i in range(process_count):
            pid = random.randint(1000, 9999)
            if i == 0:
                name = 'suspicious_process.py'
            else:
                process_names = ['init', 'systemd', 'bash', 'sshd', 'apache2']
                name = random.choice(process_names)
            
            test_data.extend(struct.pack('<I', pid))
            name_bytes = name.encode('utf-8')
            test_data.extend(name_bytes)
            test_data.extend(b'\x00' * (32 - len(name_bytes)))
        
        # Add network connections
        suspicious_ports = [8080, 4444, 5555, 6666]
        for port in suspicious_ports:
            network_str = f"127.0.0.1:{port}".encode('utf-8')
            test_data.extend(network_str)
            test_data.extend(b'\x00' * (64 - len(network_str)))
    
    elif os_type.lower() == "macos":
        test_data.extend(b'Darwin XNU mach_kernel')
        test_data.extend(b'\x00' * 100)
        
        # Similar to Linux but with macOS-specific processes
        process_count = random.randint(40, 100)
        for i in range(process_count):
            pid = random.randint(1000, 9999)
            if i == 0:
                name = 'suspicious_process.py'
            else:
                process_names = ['kernel_task', 'launchd', 'WindowServer', 'Dock', 'Finder']
                name = random.choice(process_names)
            
            test_data.extend(struct.pack('<I', pid))
            name_bytes = name.encode('utf-8')
            test_data.extend(name_bytes)
            test_data.extend(b'\x00' * (32 - len(name_bytes)))
    
    # Fill remaining space
    target_size = size_mb * 1024 * 1024
    while len(test_data) < target_size:
        # Add some random data but also include malware artifact references
        if random.random() < 0.1:  # 10% chance to add artifact reference
            artifact_ref = random.choice([
                b'suspicious', b'credential', b'stolen', b'keylogger', 
                b'backdoor', b'encrypted', b'malware_test'
            ])
            test_data.extend(artifact_ref)
            test_data.extend(b'\x00' * random.randint(10, 100))
        else:
            test_data.extend(b'\x00' * min(1024, target_size - len(test_data)))
    
    # Write the dump file
    with open(filename, 'wb') as f:
        f.write(test_data)
    
    file_size = os.path.getsize(filename) / (1024*1024)
    print(f"Memory dump created: {filename}")
    print(f"Size: {file_size:.2f} MB")
    print(f"Contains malware simulation artifacts")
    return filename

def main():
    """Main function"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Create memory dump with malware artifacts")
    parser.add_argument("--filename", "-f", default="memory_dump_with_malware.raw", 
                       help="Output filename (default: memory_dump_with_malware.raw)")
    parser.add_argument("--size", "-s", type=int, default=50, 
                       help="Size in MB (default: 50)")
    parser.add_argument("--os-type", "-o", choices=["windows", "linux", "macos"], 
                       default="windows", help="OS type (default: windows)")
    
    args = parser.parse_args()
    
    create_malware_memory_dump(args.filename, args.size, args.os_type)
    print("\nSUCCESS: Memory dump with malware artifacts created!")
    print(f"You can now run: py -m unified_forensics experiment {args.filename} --os-type {args.os_type}")

if __name__ == "__main__":
    main()
